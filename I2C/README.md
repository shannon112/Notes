# Intro:
The **Inter-Integrated Circuit** (I2C, pronounced I-squared-C) is a synchronous, multi-master, multi-slave, packet switched, single-ended, serial communication bus invented in 1982 by Philips Semiconductor (now NXP Semiconductors). It is widely used for attaching lower-speed peripheral ICs to processors and microcontrollers in short-distance, intra-board communication. Alternatively, I2C is spelled I2C (pronounced I-two-C) or IIC (pronounced I-I-C). Typical applications include GY series IMU and RTC clock module.[1]

# Character:
- **Master-Slave-Based**, multi-master, multi-slave.
- **Half-Duplex communication**, sharing one SDA line, can transmit and receive data, but not at the same time.
- **Synchronous communication**, the data from the master or the slave is synchronized on the clock edge.
- **Address**, it can connect 128 (112) devices when using 7 bits addressing and up to almost 1024 (1008) devices when using 10 bits addressing. (There are a few reserved addresses such as 1111 XXX and 0000 XXX. So that 128-8-8=112.)

# Interface:
- **SDA**：Serial Data 串列資料. Transmits data from the master to the slave or slave to the master.  
- **SCL**：Serial Clock 串列時脈. Synchronize the data transfer between the devices on the I2C bus and it’s generated by the master device.  

Since I2C is **active low**, if the two lines are “open-drain”, they need pull-up resistors such as 2K and 10K for 400kbps and 100kbps speed. Moreover, the **Arduino Uno has pullup resistors built in** that pull the SDA and SCK to 5 volts. An example schematic with one master (a microcontroller), three slave nodes (an ADC, a DAC, and a microcontroller), and pull-up resistors Rp is shown below.
<img src="https://raw.githubusercontent.com/shannon112/Notes/main/I2C/I2C_interface.png" width=400>

# Data Transmission
The data signal is transferred in sequences of 8 bits. The start condition occurs when data line drops low while the clock line is still high. After this the clock starts and each data bit is transferred during each clock pulse. The first 8 bits sequence which indicates the address of the slave (e.g. accelerometer ADXL345 in GY-80) to which the data is being sent. After each 8 bits sequence follows a bit called Acknowledge. After the first Acknowledge bit in most cases comes another addressing sequence but this time for the internal registers of the slave device (e.g. x-axis reading in ADXL345). Right after the addressing sequences follows the data sequences as many until the data is completely sent and it ends with a special stop condition.[2]  
- The start condition occurs when data line drops low while the clock line is still high.
- The device addressing sequence stars with the most significant bit (MSB) first and ends with the least significant bit (LSB)
- The first 8 bits sequence composed of 7 bits address, and the 8th bit is used for indicating whether the master will write to the slave (logic low) or read from it (logic high).
- The next bit AKC/ NACK is used by the slave device to indicate whether it has successfully received the previous sequence of bits. The master device hands the control of the SDA line over to the slave device and if the slave device has successfully received the previous sequence it will pull the SDA line down, it is called Acknowledge. If the slave does not pull the SDA line down, the condition is called Not Acknowledge, and means that it didn’t successfully received the previous sequence which can be caused by several reasons. For example, the slave might be busy, might not understand the received data or command, cannot receive any more data and so on. In such a case the master device decides how it will proceed.
- The internal registers addressing: The internal registers are locations in the slave’s memory containing various information or data. For example the ADX345 Accelerometer has a unique device address and addition internal registers addresses for the X, Y and Z axis. So if we want to read the data of the X-axis, first we need to send the device address and then the particular internal register address for the X-axis. These addresses can be found from datasheet of the sensor.
- After the addressing, the data transfer sequences begin either from the master or the slave depending of the selected mode at the R/W bit. After the data is completely sent, the transfer will end with a stop condition which occurs when the SDA line goes from low to high while the SCL line is high.
<img src="https://raw.githubusercontent.com/shannon112/Notes/main/I2C/data_transmission.jpg" width=700>
<img src="https://raw.githubusercontent.com/shannon112/Notes/main/I2C/data_transmission2.jpg" width=700>

# Pros and cons 
- Advantages [1]  
- Disadvantages [1]  

# Demo: I2C GY-80 and GY-521 Reading
Original experiment from: https://howtomechatronics.com/tutorials/arduino/how-i2c-communication-works-and-how-to-use-it-with-arduino/ [2]

<img src="https://raw.githubusercontent.com/shannon112/Notes/main/I2C/GY_address.png" height=250> <img src="https://raw.githubusercontent.com/shannon112/Notes/main/I2C/Connection.png" height=250>

```c
#include <Wire.h>
int ADXLAddress = 0x53; // Device address in which is also included the 8th bit for selecting the mode, read in this case.
#define X_Axis_Register_DATAX0 0x32 // Hexadecima address for the DATAX0 internal register.
#define X_Axis_Register_DATAX1 0x33 // Hexadecima address for the DATAX1 internal register.
#define Power_Register 0x2D // Power Control Register
int X0,X1,X_out;
void setup() {
  Wire.begin(); // Initiate the Wire library
  Serial.begin(9600);
  delay(100);
  // Enable measurement
  Wire.beginTransmission(ADXLAddress);
  Wire.write(Power_Register);
  // Bit D3 High for measuring enable (0000 1000)
  Wire.write(8);  
  Wire.endTransmission();
}
void loop() {
  Wire.beginTransmission(ADXLAddress); // Begin transmission to the Sensor 
  //Ask the particular registers for data
  Wire.write(X_Axis_Register_DATAX0);
  Wire.write(X_Axis_Register_DATAX1);
  
  Wire.endTransmission(); // Ends the transmission and transmits the data from the two registers
  
  Wire.requestFrom(ADXLAddress,2); // Request the transmitted two bytes from the two registers
  
  if(Wire.available()<=2) {  // 
    X0 = Wire.read(); // Reads the data from the register
    X1 = Wire.read();   
  }
  
  Serial.print("X0= ");
  Serial.print(X0);
  Serial.print("   X1= ");
  Serial.println(X1);
}
```
- GY-80 consists 5 different sensors and the GY-521 consists 3 different sensors. But there are only 5 device address.
- The device address and internal registers address can be found in datasheet

# Open Drain v.s. Push Pull
When you configure the GPIO pin of a microcontroller as Output. The Output pin can either be as Open-Drain type or  Push-Pull Type. Both these configurations tell us how the GPIO pin of uC is designed internally. In most cases the push-pull type will be more advantageous than Open Drain Type. And modern MCUs have Push-Pull type [3]
- Open-Drain Type: There will be only one switch (transistor/MOSFET) inside the uC and this switch is connected to Ground and the other will be left floating.
- Push-Pull Type: There will be two switches (transistor/MOSFET) inside the uC and one switch will be connected to Ground and the other will be connected to Vcc/Vdd. 
<img src="https://raw.githubusercontent.com/shannon112/Notes/main/I2C/Open_Drain_Push_Pull.png" width=600>

# Reference
[1] https://en.wikipedia.org/wiki/I%C2%B2C  
[2] https://www.youtube.com/watch?v=6IAkYpmA1DQ
[3] https://circuitdigest.com/forums/embedded/difference-between-open-drain-and-push-pull
